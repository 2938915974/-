# mysql基础

[TOC]

## 基本操作

### 创建数据库

```SQL
CREATE DATABASE 数据库名;
```

### 删除数据库

```SQL
drop database [数据库名];
```

### 选择数据库

```SQL
use [数据库名]
```

### 创建表

```SQL
CREATE TABLE IF NOT EXISTS `[表名]`(
   [列名1] [数据类型]  [是否允许空值],
   [列名2] [数据类型] [是否允许空值],
   ………………
   PRIMARY KEY ( [列名] )  /* 主键 */
)DEFAULT CHARSET=utf8MB4;
```

- [属性名]：自定义，区分大小写，不可为中文。
- [数据类型]：int ，varchar 等等
    如果数据是整数类型，那么还有以下几个设定：
  - **自动增加** `AUTO_INCREMENT` ：每一次数据录入都可以不用输入此项的值，默认增加一。
    > 通常用于主键中
  - **无符号** `UNSIGNED` ：整数类型通常是负多少到正多少的范围，设置了无符号后，就不能出现负数了，但是正数的数值上限多了一倍（把负数的范围补到了正数上）
  - `PRIMARY KEY ( [属性名] )` ：设置哪个属性为主键。
    > 主键：在表中具有唯一性，不可重复。
- 是否允许空值：允许空值就填 `null` ，不允许就填 `not null` 。
- `ENGINE=InnoDB` ：设置数据库引擎为 InnoDB
- `CHARSET=utf8MB4` ：设置字符编码类型为 utf8

此外针对所有类型列名,还有以下

- `COMMENT'[内容]'` : 注释,可以在数据库中查看的注释(可用于表和列)
- `DEFAULT [内容]` : 默认值,当传值为空时会直接采用这个值(在表上可用于设置默认属性)

### 删除数据表

```SQL
DROP TABLE [表名1],[表名2] ;
```

### 插入数据

- ``` SQL
  INSERT INTO [表名] ( [列名1],[列名2,][……] )
         VALUES
         ( [数据11], [数据12],[……] );
         ( [数据21], [数据22],[……] );
  ………………………
  ```

  - 列名必须与数据值一一对应
  - 如果数据本身就与表中的列名对应，那么列名那一段就不需要，如：

      ```SQl
      INSERT INTO [表名] VALUES
      ( [数据11], [数据12],[……] );
      ( [数据21], [数据22],[……] );
      ………………………
      ```

  - 注意数据一定要与表中设置的格式相同，int对应数字，vachar对应混合，穿错会报错。

- mysql也支持将一个表的内容插入到另一个表中，代码如下

  ```sql
  INSERT INTO [表名] ([列名1]，[列名2],……) 
         SELECT [列名1],[列名2],…… 
         FROM [表名] 
         where [条件1],[条件2],……
  ```

  > 注意，插入指令在列表中已有数据的情况下是无法进行的，有些时候哪怕数据是 null 也不行。
  > 还有，需要注意插入配查询，没有 values

- 如果要进行判断插入，如判断条件为：[表1].[id] = [表2].[id] 时，才进行插入

  ```SQL
  insert INTO [表1]([列名],[列名2],……) 
        SELECT [表名].[列名1] , [表名].[列名2],……
        FROM [表1],[表2]
        WHERE [表1].[id]=[表2].[id]
  ```

  > $~~~~~$ **注意**，`SELECT FROM` 的表名与 `UPDATE` 后面的表名都是语句执行的范围，不论是执行的查询/更新的内容，还是后面的判断语句，都都是从这个范围中查找数据。
  > $~~~~~$ 换句话说，这里没有添加表，后面的语句就无法找到表，更不可能找到表中的数据了。
  >> $~~~~~$ 只有少数自带查找的判断语句，如 INNER JOIN 可以不用在语句的执行范围中添加。
  > $~~~~~$ `[表1].[id]` 表示表1 中的 id 列 ，在 SQL 语句涉及多表时指定表名可以避免出错，在单表的时候可以不用指定表名。

- 如果插入的数据不是用 select 查找的话，那么判断语句就会有很大的不同

```SQL
insert into [表名] ([列名1] , [列名2] , ……) 
      SELECT [数据1] , [数据2] , ……
      from DUAL
      where [条件1] , [条件2] , ;
```

$~~~~~$ DUAL 是一个特殊的表，无论我们查询什么，都会存在。所以此处通过将插入的数据用于查询 DUAL ，那么我们的数据也会返回回来。
$~~~~~$ 因此该句的效果就是伪造一个查询语句，用于使用 where 语句。

### 数据查询条件语句

```SQL
SELECT [表名].[列名] , [表名].[列名] , ……
      FROM [表1] , [表2] , ……
      WHERE [条件1] AND/OR [条件2] AND/OR [条件3].....
```

在查询语句中，可以用 `*` 来表示符合条件的数据的数据属性，如

```SQL
SELECT * FROM [表名]
```

这时就会返回整个表的所有数据。

### 判断语句

WHERE 是判断语句，可以用在查询，添加，插入，删除，等几乎有所的 SQL 语句中，如

```SQL
where id > 100
where name = "李华"
```

如果值符合后面的数据，就会判断为真并将该数据所在的行返回。

WHERE 的初级判定符有以下几个（符合判定条件会返回 ture，不符合返回 false）

- `=`  ： 等号，检测两个值是否相等
- `<>, !=` ：不等于，检测两个值是否相等
- `>` ： 大于号，检测左边的值是否大于右边的值
- `<` ： 小于号，检测左边的值是否小于右边的值
- `>=` ： 大于等于号，检测左边的值是否大于或等于右边的值
- `<=` ： 小于等于号，检测左边的值是否小于或等于右边的值

where 中也可以放入查询语句作为判断条件，查询有为真，无则为假

```SQL
where (select …… )
```

在where 中 select 语句通常会放在括号，以表示该语句为一个整体条件。

> 几乎 where 语句中镶嵌的所有语句都是作为真假判断。

### 数据更新条件语句

$~~~~~$ 数据更新 update 语句将 set 等号后面的数赋值给等号前面的数据，如果数据已经存在，则直接覆盖。

```SQL
UPDATE [表1],[表2] 
      SET [属性名1]=[属性值], [属性名2]=[属性值]
      WHERE [条件1] AND/OR [条件2] AND/OR [条件3] .....
```

数据更新一样支持将其他表的数据复制到本表中

```SQL
UPDATE [表1],[表2] 
       set [表名1].[列名1] = [表名2].[列名2] , 
           [表名3].[列名3] = [表名4].[列名4] , 
       ………………
       WHERE [条件1] , [条件2] , ……
```

## 关键字

几乎所有的关键字都是 `where` 中的判断条件，具体是不是，可以看示范代码。

#### 单功能属性

`LOWER([列名])` ：将所有大写字母转换为小写字母
`UCASE([列名])` ：将所有小写字母转换为大字字母

#### LIKE 与 通配符

$~~~~~$ like 在英语中有像的意思，在 mysql 语句中也是这个作用，因此 like 需要与通配符进行联用，实现模糊查询，下面是最常用的两个通配符

`%` ： 代表零或多个字符
`-` ： 仅代表一个字符

下面是 `like` 的使用范例

```SQL
SELECT [列名1],[列名2],……
       FROM [表名]
       WHERE [列名] LIKE [含有通配符的数据]
```

$~~~~~$ `WHERE [列名] LIKE [含有通配符的数据]` 即模糊查询，不管通配符中的数据是什么，只要其他内容与明确数据相同，就会判断为真然后返回，如 `where like id = 2022*` 。

#### `IN`

$~~~~~$ IN 操作符允许我们在 WHERE 子句中规定多个值，`WHERE column_name IN (value1,value2,...)` ，满足只要满足其中一个数值相同，就判定为真。

#### BETWEEN

$~~~~~$ BETWEEN 英文意思是在什么之间，在 SQL 语句中也是这个作用，通过 `BETWEEN [数据1] and [数据2]` 来判断，在这个中间的数据会被判断为真，外面的判断为假。
$~~~~~$ BETWEEN 可以用来判断数字，时间，日期，包括字母构成的单词（单词会按照字母表的顺序来判断，但不建议这么做，效率非常低），但是中文貌似不行。
$~~~~~$ 以下是使用范例

```SQL
SELECT [列名1] , [列名2]
FROM [表1] , [表2]
WHERE [列名] BETWEEN [数据1] AND [数据2]
```

通常来说，第一个数据会被作为下限，第二个会被作为上限。

#### INNER JOIN

$~~~~~$ `INNER JOIN` 是一个判断关键字。
$~~~~~$ 在表中存在匹配数据时，`INNER JOIN` 关键字返回匹配数据行。
$~~~~~$ 实际使用时，通过 `INNER JOIN` 指定外表，然后通过 `on` 关键字来进行属性判断。

```SQL
SELECT [列名1],[列名2],……
FROM [表名1]
INNER JOIN [表名2]
ON [表名1].[列名1] = [表名2].[列名2]
```

$~~~~~$ 当系统检查到 [表名1].[列名1] = [表名2].[列名2] 时，就会返回 表1 对应的那一行数据，但还是会根据 SELECT 的数据来决定显示出来的内容。

这个语句也可以直接用 `SELECT …… WHERE ……` 来实现，如下所示

```SQL
SELECT [表1].[列名1]
FROM [表1] , [表2]
WHERE [表1].[列名] = [表2].[列名]
```

#### CASE WHEN

$~~~~~$ `WHEN …… THEN ……` 语句类似于判断语句 swtich ，用于判断列表中的数据内容，如果数据与 WHEN 后面的字符串相同，就会返回对应 THEN 后面的返回值，如果都不是，就会执行 else 返回值 ，所有返回值都会存放在新建的列中，列名由 `END` 指定（也可以不指定，有默认值）。下面先展示示例代码

```SQL
SELECT [列名1],[列名2]
       CASE [列名]
       WHEN [字符串1] THEN [返回值1]
       WHEN [字符串2] THEN [返回值2]
       ……………………
       ELSE [返回值n]
       END [列名]
       FROM [表名]
```

$~~~~~$ WHEN 与 THEN 后面可以使用基础数据类型，也就是说不能使用判断语句。
$~~~~~$ 该语句创建的列是临时列，不会储存到数据库中，用完即毁。
> $~~~~~$ 在不指定新列名的时候，可以将返回值作为数据进行插入，更新，判断等操作。

CASE 后面也可以不跟列名，但是 WHEN 后面就要把名字加上了，如

```SQL
SELECT id,username
       CASE WHEN id=10 THEN 1 WHEN id=20 THEN 2
       ELSE 0
       END 
       FROM test
```

#### IF

```SQL
IF([判断语句] , [为真返回值] , [为假返回值])
```

SQL IF 的执行结果只有返回值，而不是命令。
IF 语句可以与 select 语句连用，返回值将新建一个列表放在最后
> 可以通过 `AS [列名]` 来命名返回值列，也可以不用，列名为判断语句

```SQL
SELECT [列名1] , [列名2], 
       IF([判断语句] , [为真返回值] , [为假返回值]) AS [列名]
       FROM [表名]
```

#### limit

$~~~~~$ limit 关键字可以指定查询位置与查询数量，通常用作分类，语法为 `limit [查询位置],[查询数量]` 。
> limit 关键字通常放在最后一位

```SQL
   select * from test01 limit 500,30
```

此段 SQL 语句的意思就是从 test01 表的 300 行开始，查询 30 行，实际查询的就是301~330。

由于优化问题，
